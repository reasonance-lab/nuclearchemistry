<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nuclear Reactions Simulator (TEKS-aligned)</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #0b1020; color: #e9eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { position: relative; height: 100%; overflow: hidden; }
    #canvasWrap { position: absolute; inset: 0; }
    canvas { display: block; }

    /* HUD */
    #hud {
      position: absolute; inset: 14px 14px auto 14px;
      display: grid; grid-template-columns: 1fr 420px; gap: 12px;
      pointer-events: none;
    }
    @media (max-width: 980px) {
      #hud { grid-template-columns: 1fr; }
      #rightPanel { margin-bottom: 10px; }
      #bottomBar { inset: auto 14px 14px 14px; }
    }

    .panel {
      background: rgba(10, 16, 34, 0.72);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      padding: 12px 12px;
      pointer-events: auto;
    }
    .titleRow { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 8px; }
    .titleRow h1 { font-size: 15px; margin: 0; font-weight: 700; letter-spacing: 0.2px; }
    .pill {
      font-size: 12px; padding: 4px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #e9eefc;
    }
    .row { display:flex; gap:8px; flex-wrap: wrap; align-items:center; }
    button, input, select {
      font: inherit;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: #e9eefc;
      padding: 8px 10px;
      cursor: pointer;
      outline: none;
    }
    button:hover { background: rgba(255,255,255,0.10); }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    input { cursor: text; width: 72px; }
    select { cursor: pointer; }

    .small { font-size: 12px; opacity: 0.9; line-height: 1.35; }
    .muted { opacity: 0.7; }
    .kv { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .kv div { padding: 8px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); }
    .kv .k { font-size: 11px; opacity: 0.75; }
    .kv .v { font-size: 14px; font-weight: 700; margin-top: 3px; }

    /* Mission panel */
    #missionList { max-height: 280px; overflow: auto; padding-right: 4px; }
    .mission {
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 8px;
      display:flex; flex-direction: column; gap: 6px;
    }
    .missionHeader { display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .missionHeader .name { font-weight: 800; font-size: 13px; }
    .missionHeader .tag { font-size: 11px; opacity: 0.8; }
    .mission .desc { font-size: 12px; opacity: 0.82; }
    .mission .actions { display:flex; gap:8px; flex-wrap: wrap; align-items:center; }

    /* Bottom bar */
    #bottomBar {
      position: absolute; inset: auto 14px 14px 14px;
      display: grid; grid-template-columns: 1fr; gap: 12px;
      pointer-events: none;
    }
    #equationPanel { pointer-events: auto; }
    #equation { font-size: 15px; line-height: 1.5; }
    .nuclide {
      display:inline-block; position: relative; padding-left: 22px; margin: 0 4px;
    }
    .nuclide .A { position:absolute; left:0; top:-0.55em; font-size: 0.9em; }
    .nuclide .Z { position:absolute; left:0; top:0.55em; font-size: 0.9em; }
    .nuclide .sym { font-weight: 800; }
    .blank { width: 56px; text-align:center; }

    #toast {
      position:absolute; left:50%; top: 16px; transform: translateX(-50%);
      background: rgba(20, 30, 60, 0.85);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 13px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
      opacity: 0; transition: opacity 220ms ease;
      pointer-events: none;
      max-width: min(680px, calc(100% - 28px));
    }
    #toast.show { opacity: 1; }

    /* Help drawer */
    #help {
      position:absolute; inset: 14px auto auto 14px;
      width: min(520px, calc(100% - 28px));
      display: none;
      pointer-events: auto;
    }
    #help h2 { margin: 0 0 8px 0; font-size: 14px; }
    #help ul { margin: 6px 0 0 18px; padding: 0; }
    #help li { margin: 6px 0; }

    /* Checkbox */
    .chk { display:flex; align-items:center; gap:8px; }
    .chk input { width: 16px; height: 16px; cursor: pointer; }
  </style>
</head>
<body>
<div id="app">
  <div id="canvasWrap"></div>

  <div id="toast"></div>

  <div id="hud">
    <div class="panel" id="leftPanel">
      <div class="titleRow">
        <h1>TEKS Nuclear Reactions Lab — Missions</h1>
        <div class="row">
          <span class="pill" id="xpPill">XP 0</span>
          <button id="toggleHelpBtn" title="What is this simulation?" style="pointer-events:auto;">Help</button>
        </div>
      </div>

      <div class="kv" style="margin-bottom: 10px;">
        <div>
          <div class="k">Current Nuclide</div>
          <div class="v" id="nuclideReadout">—</div>
        </div>
        <div>
          <div class="k">Stability (simplified)</div>
          <div class="v" id="stabilityReadout">—</div>
        </div>
      </div>

      <div class="row" style="margin-bottom: 8px;">
        <label class="small muted">Sandbox isotope:</label>
        <select id="sandboxIsotope">
          <option value="84,126">Po-210 (α)</option>
          <option value="6,8">C-14 (β-)</option>
          <option value="27,33">Co-60 (γ)</option>
          <option value="92,143">U-235 (fission)</option>
          <option value="1,1|1,2">H-2 + H-3 (fusion)</option>
        </select>
        <button id="loadSandboxBtn">Load</button>
        <button id="resetBtn">Reset</button>
      </div>

      <div class="row" style="margin-bottom: 10px;">
        <button id="alphaBtn">α Decay</button>
        <button id="betaBtn">β⁻ Decay</button>
        <button id="gammaBtn">γ Emission</button>
        <button id="fissionBtn">Fission</button>
        <button id="fusionBtn">Fusion</button>
      </div>

      <div class="row" style="margin-bottom: 10px;">
        <label class="chk small muted" title="Hides element symbols in the equation blanks to make balancing less guided.">
          <input id="challengeToggle" type="checkbox" />
          Challenge mode (hide symbols)
        </label>
      </div>

      <div class="small muted" style="margin-bottom: 8px;">
        Focus: balanced nuclear equations, fission vs fusion, and applications (TEKS Chemistry 112.43(c)(14)(A–C)).
      </div>

      <div id="missionList"></div>
    </div>

    <div class="panel" id="rightPanel">
      <div class="titleRow">
        <h1>Mission Control</h1>
        <span class="pill" id="badgePill">Badges 0</span>
      </div>

      <div class="small" id="missionStatus">
        Select a mission. Use the action buttons to perform the reaction, then balance the equation.
      </div>

      <hr style="border: none; border-top: 1px solid rgba(255,255,255,0.12); margin: 10px 0;" />

      <div class="kv">
        <div>
          <div class="k">Energy Meter</div>
          <div class="v" id="energyReadout">0</div>
        </div>
        <div>
          <div class="k">Safety Meter</div>
          <div class="v" id="safetyReadout">100</div>
        </div>
      </div>

      <div style="height: 10px;"></div>

      <div class="small muted">
        Scoring: +XP for correct balancing; +Energy for correct reaction type; Safety drops if you try the wrong reaction for a mission.
      </div>
    </div>
  </div>

  <div id="help" class="panel">
    <div class="titleRow">
      <h1>Help</h1>
      <button id="closeHelpBtn">Close</button>
    </div>
    <div class="small">
      <h2>How to use</h2>
      <ul>
        <li>Pick a mission (left panel). It will tell you the target process.</li>
        <li>Click the matching reaction button (α, β⁻, γ, fission, fusion).</li>
        <li>Then balance the nuclear equation in the bottom panel and submit (press Enter in a blank).</li>
        <li>Use “Sandbox isotope” if you want to explore freely.</li>
      </ul>
      <h2>Safety note</h2>
      <div class="muted">
        This simulator is conceptual and does not model engineering details (reactor design, enrichment, critical mass, etc.).
      </div>
    </div>
  </div>

  <div id="bottomBar">
    <div class="panel" id="equationPanel">
      <div class="titleRow">
        <h1>Balanced Nuclear Equation Check</h1>
        <span class="pill" id="equationHint">—</span>
      </div>
      <div id="equation" class="small muted">
        Start a mission or run a reaction to see an equation to balance.
      </div>
      <div class="row" style="margin-top: 10px;">
        <button id="checkEqBtn" disabled>Check & Submit</button>
        <button id="hintBtn" disabled>Hint (-10 XP)</button>
        <span class="small muted" id="feedback"></span>
      </div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ---------- Utilities ---------- */
const periodic = [
  "", "H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca",
  "Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr",
  "Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd",
  "Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg",
  "Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U"
];
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

function showToast(msg) {
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(() => t.classList.remove("show"), 2200);
}

function nuclideLabel(Z, N) {
  const A = Z + N;
  const sym = periodic[Z] ?? `Z${Z}`;
  return `${sym}-${A}`;
}

/* ---------- TEKS-aligned Missions ---------- */
const missions = [
  { id: "M1", title: "Alpha decay balancing", tag: "112.43(c)(14)(A)", desc: "Describe alpha decay using a balanced nuclear equation (A and Z must be conserved).", type: "alpha", start: { Z: 84, N: 126 } },
  { id: "M2", title: "Beta (β⁻) decay balancing", tag: "112.43(c)(14)(A)", desc: "Describe beta decay using a balanced nuclear equation (a neutron becomes a proton).", type: "beta", start: { Z: 6, N: 8 } },
  { id: "M3", title: "Gamma emission", tag: "112.43(c)(14)(A)", desc: "Gamma emission changes energy state but not A or Z. Show it with a nuclear equation.", type: "gamma", start: { Z: 27, N: 33 } },
  { id: "M4", title: "Fission vs fusion", tag: "112.43(c)(14)(B)", desc: "Run a fission reaction for U-235 and compare with fusion behavior.", type: "fission", start: { Z: 92, N: 143 } },
  { id: "M5", title: "Fusion reaction", tag: "112.43(c)(14)(B)", desc: "Run fusion: deuterium + tritium → helium-4 + neutron.", type: "fusion", start: { pair: [{Z:1,N:1},{Z:1,N:2}] } },
  { id: "M6", title: "Applications decision", tag: "112.43(c)(14)(C)", desc: "Choose an application for the radiation type and justify it (therapy vs imaging vs power).", type: "applications", start: { Z: 6, N: 8 } }
];

/* ---------- Game State ---------- */
const state = {
  xp: 0, badges: 0, energy: 0, safety: 100,
  currentMission: null,
  current: { Z: 6, N: 6 },
  currentPair: null,
  challenge: false
};

function addXP(delta) { state.xp = Math.max(0, state.xp + delta); document.getElementById("xpPill").textContent = `XP ${state.xp}`; }
function addBadge() { state.badges += 1; document.getElementById("badgePill").textContent = `Badges ${state.badges}`; }
function updateMeters() { document.getElementById("energyReadout").textContent = state.energy.toFixed(0); document.getElementById("safetyReadout").textContent = state.safety.toFixed(0); }

function stabilityHeuristic(Z, N) {
  const ratio = N / Math.max(1, Z);
  const A = Z + N;
  const target = A < 20 ? 1.0 : (A < 80 ? 1.25 : 1.5);
  const d = Math.abs(ratio - target);
  if (d < 0.12) return "Likely stable";
  if (d < 0.25) return "Borderline";
  return "Unstable";
}

function updateNuclideReadout() {
  if (state.currentPair) {
    const a = state.currentPair[0], b = state.currentPair[1];
    document.getElementById("nuclideReadout").textContent = `${nuclideLabel(a.Z,a.N)} + ${nuclideLabel(b.Z,b.N)}`;
    document.getElementById("stabilityReadout").textContent = "—";
    return;
  }
  document.getElementById("nuclideReadout").textContent = nuclideLabel(state.current.Z, state.current.N);
  document.getElementById("stabilityReadout").textContent = stabilityHeuristic(state.current.Z, state.current.N);
}

/* ---------- Three.js Scene ---------- */
const wrap = document.getElementById("canvasWrap");
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0b1020, 6, 28);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 3.2, 10.5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
renderer.setSize(window.innerWidth, window.innerHeight);
wrap.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = 6;
controls.maxDistance = 22;

scene.add(new THREE.HemisphereLight(0xbcd6ff, 0x203060, 0.85));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(6, 10, 4);
scene.add(dir);

const grid = new THREE.GridHelper(40, 40, 0x223355, 0x18223b);
grid.position.y = -3.2;
grid.material.opacity = 0.5;
grid.material.transparent = true;
scene.add(grid);

const nucleusGroup = new THREE.Group(); scene.add(nucleusGroup);
const extraGroup = new THREE.Group(); scene.add(extraGroup);

const protonMat = new THREE.MeshStandardMaterial({ color: 0xff4766, roughness: 0.35, metalness: 0.05 });
const neutronMat = new THREE.MeshStandardMaterial({ color: 0xc7d0df, roughness: 0.4, metalness: 0.05 });
const glowMat = new THREE.MeshStandardMaterial({ color: 0x6fc2ff, emissive: 0x0b2a55, emissiveIntensity: 1.0 });
const particleGeom = new THREE.SphereGeometry(0.18, 18, 18);
const nucleonGeom = new THREE.SphereGeometry(0.28, 18, 18);

let anim = { t: 0, mode: "idle", payload: null };

function clearGroups() {
  while (nucleusGroup.children.length) nucleusGroup.remove(nucleusGroup.children[0]);
  while (extraGroup.children.length) extraGroup.remove(extraGroup.children[0]);
}

function packPositions(count, radius) {
  const pts = [];
  const maxTries = 4000;
  let tries = 0;
  while (pts.length < count && tries < maxTries) {
    tries++;
    const p = new THREE.Vector3((Math.random()*2-1),(Math.random()*2-1),(Math.random()*2-1))
      .normalize().multiplyScalar(Math.random() * radius);
    let ok = true;
    for (const q of pts) if (p.distanceTo(q) < 0.50) { ok = false; break; }
    if (ok) pts.push(p);
  }
  while (pts.length < count) {
    pts.push(new THREE.Vector3((Math.random()*2-1),(Math.random()*2-1),(Math.random()*2-1))
      .normalize().multiplyScalar(Math.random() * radius));
  }
  return pts;
}

function buildSingleNucleus(Z, N) {
  clearGroups();
  const A = Z + N;
  const radius = 0.62 + 0.045 * Math.pow(A, 0.55);
  const positions = packPositions(A, radius);

  for (let i = positions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }

  for (let i = 0; i < A; i++) {
    const isProton = i < Z;
    const m = new THREE.Mesh(nucleonGeom, isProton ? protonMat : neutronMat);
    m.position.copy(positions[i]);
    nucleusGroup.add(m);
  }

  const shell = new THREE.Mesh(
    new THREE.SphereGeometry(radius * 1.25, 22, 22),
    new THREE.MeshStandardMaterial({ color: 0x1a2f66, emissive: 0x0b2a55, emissiveIntensity: 0.9, transparent: true, opacity: 0.18, roughness: 0.95 })
  );
  nucleusGroup.add(shell);
}

function buildFusionPair(a, b) {
  clearGroups();
  const left = new THREE.Group();
  const right = new THREE.Group();
  nucleusGroup.add(left); nucleusGroup.add(right);

  function populate(g, Z, N) {
    const A = Z + N;
    const r = 0.5 + 0.06 * Math.pow(A, 0.55);
    const positions = packPositions(A, r);
    for (let i = 0; i < A; i++) {
      const isProton = i < Z;
      const m = new THREE.Mesh(nucleonGeom, isProton ? protonMat : neutronMat);
      m.position.copy(positions[i]);
      g.add(m);
    }
    const shell = new THREE.Mesh(
      new THREE.SphereGeometry(r * 1.35, 18, 18),
      new THREE.MeshStandardMaterial({ color: 0x1a2f66, emissive: 0x0b2a55, emissiveIntensity: 0.8, transparent:true, opacity:0.18 })
    );
    g.add(shell);
  }

  populate(left, a.Z, a.N);
  populate(right, b.Z, b.N);
  left.position.set(-2.4, 0, 0);
  right.position.set(2.4, 0, 0);
}

function setSceneToCurrent() {
  if (state.currentPair) buildFusionPair(state.currentPair[0], state.currentPair[1]);
  else buildSingleNucleus(state.current.Z, state.current.N);
  updateNuclideReadout();
}

/* ---------- Conceptual nuclear processes ---------- */
function doAlphaDecay(before) { return { after: { Z: before.Z - 2, N: before.N - 2 } }; }
function doBetaMinus(before) { return { after: { Z: before.Z + 1, N: before.N - 1 } }; }
function doFusion(pair) { return { after: { Z: 2, N: 2 }, extras: { reactants: [pair[0], pair[1]] } }; }

/* ---------- Animations ---------- */
function spawnParticle(material, start, end, scale=1.0) {
  const m = new THREE.Mesh(particleGeom, material);
  m.scale.setScalar(scale);
  m.position.copy(start);
  extraGroup.add(m);
  return { mesh: m, start: start.clone(), end: end.clone() };
}

function startAnimation(kind) {
  anim = { t: 0, mode: kind, payload: { particles: [] } };
  if (kind === "alpha") {
    anim.payload.particles.push(
      spawnParticle(protonMat, new THREE.Vector3(0,0,0), new THREE.Vector3(4,1.2,0), 1.25),
      spawnParticle(neutronMat, new THREE.Vector3(0.2,0.1,0), new THREE.Vector3(4.4,1.0,0.2), 1.25),
      spawnParticle(neutronMat, new THREE.Vector3(-0.2,0.0,0), new THREE.Vector3(4.2,0.9,-0.2), 1.25),
      spawnParticle(protonMat, new THREE.Vector3(0.1,-0.1,0), new THREE.Vector3(4.6,1.1,-0.1), 1.25)
    );
  } else if (kind === "beta") {
    anim.payload.particles.push(spawnParticle(glowMat, new THREE.Vector3(0,0,0), new THREE.Vector3(4, 0.5, 0.8), 0.9));
  } else if (kind === "gamma") {
    const gMat = new THREE.MeshStandardMaterial({ color: 0x9effff, emissive: 0x2a9fb0, emissiveIntensity: 1.5 });
    anim.payload.particles.push(spawnParticle(gMat, new THREE.Vector3(0,0,0), new THREE.Vector3(5, 0, 0), 0.7));
  } else if (kind === "fission") {
    showToast("Fission: nucleus splits + releases neutrons (conceptual).");
  } else if (kind === "fusion") {
    showToast("Fusion: two nuclei merge (conceptual).");
  }
}

function easeOutCubic(x){ return 1 - Math.pow(1-x,3); }
function easeInOut(x){ return x < 0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2; }

function animateFrame(dt) {
  anim.t += dt;
  const t = anim.t;
  const p = anim.payload || {};

  if (anim.mode === "alpha" || anim.mode === "beta" || anim.mode === "gamma") {
    const k = clamp(t / 1.2, 0, 1);
    for (const part of (p.particles || [])) part.mesh.position.lerpVectors(part.start, part.end, easeOutCubic(k));
    if (k >= 1 && t > 1.35) anim.mode = "idle";
  }

  if (anim.mode === "fusion") {
    const k = clamp(t / 1.6, 0, 1);
    const left = nucleusGroup.children[0];
    const right = nucleusGroup.children[1];
    if (left && right) {
      left.position.lerpVectors(new THREE.Vector3(-2.4,0,0), new THREE.Vector3(-0.4,0,0), easeInOut(k));
      right.position.lerpVectors(new THREE.Vector3(2.4,0,0), new THREE.Vector3(0.4,0,0), easeInOut(k));
    }
    if (k >= 1 && t > 1.7) anim.mode = "idle";
  }
}

/* ---------- Equation Builder / Checker ---------- */
const eqEl = document.getElementById("equation");
const eqHintEl = document.getElementById("equationHint");
const feedbackEl = document.getElementById("feedback");
const checkBtn = document.getElementById("checkEqBtn");
const hintBtn = document.getElementById("hintBtn");

let eqModel = null;
let lastEqReaction = null;

function symFor(Z) { return state.challenge ? "?" : (periodic[Z] ?? `Z${Z}`); }

function nuclideSpan({Z,N}, allowBlank=false, idPrefix="") {
  const A = Z + N;
  const sym = symFor(Z);
  const AHtml = allowBlank ? `<input class="blank" id="${idPrefix}A" inputmode="numeric" placeholder="A" />` : `<span class="A">${A}</span>`;
  const ZHtml = allowBlank ? `<input class="blank" id="${idPrefix}Z" inputmode="numeric" placeholder="Z" />` : `<span class="Z">${Z}</span>`;
  return `<span class="nuclide">${AHtml}${ZHtml}<span class="sym">${sym}</span></span>`;
}

function setEquationForReaction(reaction) {
  lastEqReaction = reaction;
  feedbackEl.textContent = "";
  eqHintEl.textContent = reaction.hint ?? "Conserve mass number (A) and atomic number (Z)";
  checkBtn.disabled = false;
  hintBtn.disabled = false;

  const kind = reaction.kind;
  if (kind === "alpha") {
    const before = reaction.before, after = reaction.after;
    eqModel = { kind, expected: { afterA: after.Z+after.N, afterZ: after.Z } };
    eqEl.innerHTML = `${nuclideSpan(before)} → ${nuclideSpan(after, true, "d_")} + ${nuclideSpan({Z:2,N:2})} (α)`;
  } else if (kind === "beta") {
    const before = reaction.before, after = reaction.after;
    eqModel = { kind, expected: { afterA: after.Z+after.N, afterZ: after.Z } };
    eqEl.innerHTML =
      `${nuclideSpan(before)} → ${nuclideSpan(after, true, "d_")} + <span class="nuclide"><span class="A">0</span><span class="Z">-1</span><span class="sym">e</span></span> (β⁻)`;
  } else if (kind === "gamma") {
    const before = reaction.before;
    eqModel = { kind, expected: { afterA: before.Z+before.N, afterZ: before.Z } };
    const leftSym = symFor(before.Z);
    eqEl.innerHTML =
      `<span class="nuclide"><input class="blank" id="d_A" inputmode="numeric" placeholder="A" /><input class="blank" id="d_Z" inputmode="numeric" placeholder="Z" /><span class="sym">${leftSym}</span></span>` +
      ` → ${nuclideSpan(before)} + <span class="sym">γ</span>`;
  } else if (kind === "fusion") {
    const [a,b] = reaction.reactants;
    eqModel = { kind, expected: {} };
    const heSym = state.challenge ? "?" : "He";
    eqEl.innerHTML =
      `${nuclideSpan(a)} + ${nuclideSpan(b)} → ` +
      `<span class="nuclide"><input class="blank" id="p_A" inputmode="numeric" placeholder="A" /><input class="blank" id="p_Z" inputmode="numeric" placeholder="Z" /><span class="sym">${heSym}</span></span>` +
      ` + <span class="nuclide"><input class="blank" id="n_A" inputmode="numeric" placeholder="A" /><input class="blank" id="n_Z" inputmode="numeric" placeholder="Z" /><span class="sym">n</span></span>`;
  } else if (kind === "fission") {
    eqModel = { kind, expected: { neutrons: 3 } };
    eqEl.innerHTML =
      `<span class="small">Balance the neutron count:</span><br/>` +
      `${nuclideSpan({Z:92,N:143})} + <span class="nuclide"><span class="A">1</span><span class="Z">0</span><span class="sym">n</span></span> → ` +
      `${nuclideSpan({Z:56,N:85})} + ${nuclideSpan({Z:36,N:56})} + ` +
      `<input class="blank" id="k_n" inputmode="numeric" placeholder="n?" />` +
      `<span class="nuclide"><span class="A">1</span><span class="Z">0</span><span class="sym">n</span></span>`;
  } else if (kind === "applications") {
    eqModel = { kind, expected: {} };
    eqEl.innerHTML =
      `<div class="small">Pick a best-fit application:</div>
       <div class="row" style="margin-top:8px;">
         <select id="appPick">
           <option value="">Choose…</option>
           <option value="alpha">α: smoke detectors / high ionization (shielded)</option>
           <option value="beta">β⁻: thickness gauge / some tracers</option>
           <option value="gamma">γ: diagnostic imaging / therapy (high penetration)</option>
           <option value="fission">Fission: nuclear power (electricity)</option>
           <option value="fusion">Fusion: stars (energy source)</option>
         </select>
         <input id="appWhy" style="width: min(360px, 100%);" placeholder="One-sentence justification…" />
       </div>`;
  }
}

function scoreResult(ok, msg) {
  feedbackEl.textContent = msg;
  if (ok) {
    addXP(40);
    state.energy += 25;
    state.safety = clamp(state.safety + 2, 0, 100);
    updateMeters();
    if (state.currentMission && !state.currentMission.completed) {
      state.currentMission.completed = true;
      addBadge();
      showToast(`Mission complete: ${state.currentMission.title}`);
      renderMissions();
      setActionLocks(null);
    } else showToast("Correct!");
  } else {
    state.safety = clamp(state.safety - 6, 0, 100);
    updateMeters();
    addXP(-5);
    showToast("Try again.");
  }
}

function checkEquation() {
  if (!eqModel) return;

  if (eqModel.kind === "alpha" || eqModel.kind === "beta") {
    const A = parseInt(document.getElementById("d_A")?.value, 10);
    const Z = parseInt(document.getElementById("d_Z")?.value, 10);
    const ok = (A === eqModel.expected.afterA) && (Z === eqModel.expected.afterZ);
    scoreResult(ok, ok ? "Correct. A and Z are conserved." : "Not yet. Check that A and Z are conserved.");
    return;
  }

  if (eqModel.kind === "gamma") {
    const A = parseInt(document.getElementById("d_A")?.value, 10);
    const Z = parseInt(document.getElementById("d_Z")?.value, 10);
    const ok = (A === eqModel.expected.afterA) && (Z === eqModel.expected.afterZ);
    scoreResult(ok, ok ? "Correct. γ emission does not change A or Z." : "Not yet. γ emission keeps A and Z the same.");
    return;
  }

  if (eqModel.kind === "fusion") {
    const pA = parseInt(document.getElementById("p_A")?.value, 10);
    const pZ = parseInt(document.getElementById("p_Z")?.value, 10);
    const nA = parseInt(document.getElementById("n_A")?.value, 10);
    const nZ = parseInt(document.getElementById("n_Z")?.value, 10);
    const ok = (pA===4 && pZ===2 && nA===1 && nZ===0);
    scoreResult(ok, ok ? "Correct. Fusion conserves A and Z." : "Not yet. Try He-4 plus one neutron.");
    return;
  }

  if (eqModel.kind === "fission") {
    const k = parseInt(document.getElementById("k_n")?.value, 10);
    const ok = (k === eqModel.expected.neutrons);
    scoreResult(ok, ok ? "Correct. Neutron count balances the mass numbers." : "Not yet. Re-check A totals on each side.");
    return;
  }

  if (eqModel.kind === "applications") {
    const pick = document.getElementById("appPick")?.value;
    const why = (document.getElementById("appWhy")?.value || "").trim();
    const ok = !!pick && why.length >= 10;
    scoreResult(ok, ok ? "Good. You connected a nuclear phenomenon to a real application." : "Add a choice and a brief justification (≥10 characters).");
  }
}

function showHint() {
  if (!eqModel) return;
  addXP(-10);
  if (eqModel.kind === "alpha") showToast("Alpha decay: A decreases by 4, Z decreases by 2.");
  else if (eqModel.kind === "beta") showToast("β⁻ decay: A stays same; Z increases by 1.");
  else if (eqModel.kind === "gamma") showToast("γ emission: A and Z do not change.");
  else if (eqModel.kind === "fusion") showToast("D+T fusion makes He-4 and a neutron.");
  else if (eqModel.kind === "fission") showToast("Total A must match. U-235 + 1 = 236 on the left.");
  else showToast("Use: penetration (γ > β > α), and common uses (therapy/imaging/power).");
}

/* ---------- Missions ---------- */
const missionListEl = document.getElementById("missionList");
const missionStatusEl = document.getElementById("missionStatus");

function renderMissions() {
  missionListEl.innerHTML = "";
  for (const m of missions) {
    const div = document.createElement("div");
    div.className = "mission";
    div.innerHTML = `
      <div class="missionHeader">
        <div class="name">${m.title}</div>
        <div class="tag">${m.tag}</div>
      </div>
      <div class="desc">${m.desc}</div>
      <div class="actions">
        <button data-mid="${m.id}">${m.completed ? "Review" : "Start"}</button>
        <span class="pill">${m.completed ? "✓ Done" : "Not done"}</span>
      </div>
    `;
    div.querySelector("button").addEventListener("click", () => startMission(m.id));
    missionListEl.appendChild(div);
  }
}

function setActionLocks(type) {
  const alphaBtn = document.getElementById("alphaBtn");
  const betaBtn = document.getElementById("betaBtn");
  const gammaBtn = document.getElementById("gammaBtn");
  const fissionBtn = document.getElementById("fissionBtn");
  const fusionBtn = document.getElementById("fusionBtn");

  [alphaBtn,betaBtn,gammaBtn,fissionBtn,fusionBtn].forEach(b => b.disabled = false);

  if (!type) return;
  if (!state.currentMission || state.currentMission.completed) return;

  [alphaBtn,betaBtn,gammaBtn,fissionBtn,fusionBtn].forEach(b => b.disabled = true);

  if (type === "alpha") alphaBtn.disabled = false;
  if (type === "beta") betaBtn.disabled = false;
  if (type === "gamma") gammaBtn.disabled = false;
  if (type === "fission") fissionBtn.disabled = false;
  if (type === "fusion") fusionBtn.disabled = false;
  if (type === "applications") {
    [alphaBtn,betaBtn,gammaBtn,fissionBtn,fusionBtn].forEach(b => b.disabled = false);
    setEquationForReaction({ kind: "applications", hint: "Explain why the radiation/process fits the application" });
  }
}

function startMission(mid) {
  const m = missions.find(x => x.id === mid);
  if (!m) return;
  state.currentMission = m;
  missionStatusEl.textContent = `Active mission: ${m.title} (${m.tag}). ${m.desc}`;

  if (m.type === "fusion") { state.currentPair = m.start.pair; state.current = { Z: 0, N: 0 }; }
  else { state.currentPair = null; state.current = m.start; }

  setSceneToCurrent();

  eqModel = null; lastEqReaction = null;
  eqEl.textContent = (m.type === "applications") ? "Complete the application choice below." : "Run the required reaction button, then balance the equation.";
  eqHintEl.textContent = "—"; feedbackEl.textContent = "";
  checkBtn.disabled = true; hintBtn.disabled = true;

  setActionLocks(m.type);
  showToast(`Mission started: ${m.title}`);
}

/* ---------- Actions ---------- */
function ensureMissionMatch(kind) {
  if (!state.currentMission || state.currentMission.completed) return true;
  const expected = state.currentMission.type;
  if (expected === kind) return true;
  state.safety = clamp(state.safety - 10, 0, 100);
  updateMeters();
  showToast("Wrong reaction for this mission. Read the mission prompt.");
  return false;
}

function runAlpha() {
  if (!state.currentPair && state.current.Z >= 2 && state.current.N >= 2) {
    if (!ensureMissionMatch("alpha")) return;
    const before = { ...state.current };
    const r = doAlphaDecay(before);
    state.current = r.after;
    setSceneToCurrent();
    startAnimation("alpha");
    setEquationForReaction({ kind: "alpha", before, after: r.after, hint: "Alpha: A−4, Z−2" });
    state.energy += 10; updateMeters();
  } else showToast("Load a heavy nuclide (Sandbox) for alpha decay.");
}

function runBeta() {
  if (!state.currentPair && state.current.N >= 1) {
    if (!ensureMissionMatch("beta")) return;
    const before = { ...state.current };
    const r = doBetaMinus(before);
    state.current = r.after;
    setSceneToCurrent();
    startAnimation("beta");
    setEquationForReaction({ kind: "beta", before, after: r.after, hint: "β⁻: A same, Z+1" });
    state.energy += 8; updateMeters();
  } else showToast("Load a single nuclide (not a fusion pair) for β⁻ decay.");
}

function runGamma() {
  if (!state.currentPair) {
    if (!ensureMissionMatch("gamma")) return;
    const before = { ...state.current };
    startAnimation("gamma");
    setEquationForReaction({ kind: "gamma", before, after: before, hint: "γ: A and Z unchanged" });
    state.energy += 5; updateMeters();
  } else showToast("Gamma emission is shown on a single nucleus. Load a single nuclide.");
}

function runFusion() {
  if (state.currentPair) {
    if (!ensureMissionMatch("fusion")) return;
    const r = doFusion(state.currentPair);
    state.currentPair = null;
    state.current = r.after;
    setSceneToCurrent();
    startAnimation("fusion");
    setEquationForReaction({ kind: "fusion", reactants: r.extras.reactants, hint: "D+T → He-4 + n" });
    state.energy += 18; updateMeters();
  } else showToast("Load the fusion pair (H-2 + H-3) from Sandbox.");
}

function runFission() {
  if (!state.currentPair && state.current.Z === 92) {
    if (!ensureMissionMatch("fission")) return;
    startAnimation("fission");
    setEquationForReaction({ kind: "fission", hint: "U-235 + n → Ba-141 + Kr-92 + 3n" });
    state.energy += 20; updateMeters();
  } else showToast("Load U-235 from Sandbox to run fission.");
}

/* ---------- Sandbox loading ---------- */
function loadSandboxSelection() {
  const v = document.getElementById("sandboxIsotope").value;
  if (v.includes("|")) {
    const [a,b] = v.split("|").map(s => s.split(",").map(Number));
    state.currentPair = [{Z:a[0], N:a[1]}, {Z:b[0], N:b[1]}];
    state.current = { Z: 0, N: 0 };
  } else {
    const [Z,N] = v.split(",").map(Number);
    state.currentPair = null;
    state.current = { Z, N };
  }
  state.currentMission = null;
  setSceneToCurrent();
  eqModel = null; lastEqReaction = null;
  eqEl.textContent = "Sandbox loaded. Run a reaction to generate an equation.";
  eqHintEl.textContent = "—"; feedbackEl.textContent = "";
  checkBtn.disabled = true; hintBtn.disabled = true;
  missionStatusEl.textContent = "Sandbox mode. Select a mission if you want guided scaffolds and scoring.";
  setActionLocks(null);
}

/* ---------- Wiring ---------- */
document.getElementById("alphaBtn").addEventListener("click", runAlpha);
document.getElementById("betaBtn").addEventListener("click", runBeta);
document.getElementById("gammaBtn").addEventListener("click", runGamma);
document.getElementById("fissionBtn").addEventListener("click", runFission);
document.getElementById("fusionBtn").addEventListener("click", runFusion);

document.getElementById("loadSandboxBtn").addEventListener("click", loadSandboxSelection);

document.getElementById("resetBtn").addEventListener("click", () => {
  state.xp = 0; state.badges = 0; state.energy = 0; state.safety = 100;
  missions.forEach(m => delete m.completed);
  addXP(0);
  document.getElementById("badgePill").textContent = "Badges 0";
  updateMeters();
  loadSandboxSelection();
  renderMissions();
  showToast("Reset complete.");
});

document.getElementById("challengeToggle").addEventListener("change", (e) => {
  state.challenge = !!e.target.checked;
  showToast(state.challenge ? "Challenge mode ON (symbols hidden)." : "Challenge mode OFF (symbols shown).");
  if (lastEqReaction) setEquationForReaction(lastEqReaction);
});

document.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !checkBtn.disabled) {
    const tag = (document.activeElement?.tagName || "").toLowerCase();
    if (tag === "input") checkEquation();
  }
});

checkBtn.addEventListener("click", checkEquation);
hintBtn.addEventListener("click", showHint);

/* Help drawer */
const help = document.getElementById("help");
document.getElementById("toggleHelpBtn").addEventListener("click", () => help.style.display = "block");
document.getElementById("closeHelpBtn").addEventListener("click", () => help.style.display = "none");

/* Resize */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ---------- Start ---------- */
function setDefault() {
  state.current = { Z: 6, N: 8 };
  state.currentPair = null;
  setSceneToCurrent();
  addXP(0);
  updateMeters();
  renderMissions();
  missionStatusEl.textContent = "Select a mission (guided) or use Sandbox to explore.";
  showToast("Loaded. Start with Mission 1.");
}
setDefault();

/* ---------- Render Loop ---------- */
let last = performance.now();
function loop(now) {
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;

  controls.update();
  animateFrame(dt);

  nucleusGroup.rotation.y += 0.15 * dt;
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>