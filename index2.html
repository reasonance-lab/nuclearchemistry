<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nuclear Reactions Simulator (TEKS-aligned)</title>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #0b1020; color: #e9eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { position: relative; height: 100%; overflow: hidden; }
    #canvasWrap { position: absolute; inset: 0; }
    canvas { display: block; }

    /* HUD */
    #hud {
      position: absolute; inset: 14px 14px auto 14px;
      display: grid; grid-template-columns: 1fr 420px; gap: 12px;
      pointer-events: none;
    }
    @media (max-width: 980px) {
      #hud { grid-template-columns: 1fr; }
      #rightPanel { margin-bottom: 10px; }
      #bottomBar { inset: auto 14px 14px 14px; }
    }

    .panel {
      background: rgba(10, 16, 34, 0.72);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      padding: 12px 12px;
      pointer-events: auto;
    }
    .stepCard {
      border: 1px dashed rgba(255,255,255,0.22);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
      background: rgba(255,255,255,0.02);
      position: relative;
    }
    .stepCard.locked { opacity: 0.55; }
    .stepLabel {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; letter-spacing: 0.2px; text-transform: uppercase;
      padding: 4px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
    }
    .stepLabel .icon { font-size: 14px; }
    .stepHint { font-size: 12px; opacity: 0.82; margin: 6px 0 10px 0; display: block; }
    .titleRow { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 8px; }
    .titleRow h1 { font-size: 15px; margin: 0; font-weight: 700; letter-spacing: 0.2px; }
    .pill {
      font-size: 12px; padding: 4px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #e9eefc;
    }
    .row { display:flex; gap:8px; flex-wrap: wrap; align-items:center; }
    button, input, select {
      font: inherit;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: #e9eefc;
      padding: 8px 10px;
      cursor: pointer;
      outline: none;
    }
    button:hover { background: rgba(255,255,255,0.10); }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    input { cursor: text; width: 72px; }
    select { cursor: pointer; }

    .small { font-size: 12px; opacity: 0.9; line-height: 1.35; }
    .muted { opacity: 0.7; }
    .kv { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .kv div { padding: 8px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); }
    .kv .k { font-size: 11px; opacity: 0.75; }
    .kv .v { font-size: 14px; font-weight: 700; margin-top: 3px; }

    .chipRow { display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
    .chip { display:inline-flex; align-items:center; gap:4px; font-size: 12px; padding: 6px 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.05); }
    .chip .dot { width: 10px; height: 10px; border-radius: 50%; display:inline-block; }
    .chip .dot.proton { background: #ff4766; box-shadow: 0 0 6px rgba(255,71,102,0.8); }
    .chip .dot.neutron { background: #c7d0df; }
    .chip .dot.gamma { background: #9effff; box-shadow: 0 0 6px rgba(158,255,255,0.8); }
    .chip .dot.beta { background: #6fc2ff; box-shadow: 0 0 6px rgba(111,194,255,0.8); }

    /* Mission panel */
    #missionList { max-height: 280px; overflow: auto; padding-right: 4px; }
    .mission {
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 8px;
      display:flex; flex-direction: column; gap: 6px;
    }
    .missionHeader { display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .missionHeader .name { font-weight: 800; font-size: 13px; }
    .missionHeader .tag { font-size: 11px; opacity: 0.8; }
    .mission .desc { font-size: 12px; opacity: 0.82; }
    .mission .actions { display:flex; gap:8px; flex-wrap: wrap; align-items:center; }

    /* Bottom bar */
    #bottomBar {
      position: absolute; inset: auto 14px 14px 14px;
      display: grid; grid-template-columns: 1fr; gap: 12px;
      pointer-events: none;
    }
    #equationPanel { pointer-events: auto; }
    #equation { font-size: 15px; line-height: 1.5; }
    .nuclide {
      display:inline-block; position: relative; padding-left: 22px; margin: 0 4px;
    }
    .nuclide .A { position:absolute; left:0; top:-0.55em; font-size: 0.9em; }
    .nuclide .Z { position:absolute; left:0; top:0.55em; font-size: 0.9em; }
    .nuclide .sym { font-weight: 800; }
    .blank { width: 56px; text-align:center; }

    #toast {
      position:absolute; left:50%; top: 16px; transform: translateX(-50%);
      background: rgba(20, 30, 60, 0.85);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 13px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
      opacity: 0; transition: opacity 220ms ease;
      pointer-events: none;
      max-width: min(680px, calc(100% - 28px));
    }
    #toast.show { opacity: 1; }

    /* Help drawer */
    #help {
      position:absolute; inset: 14px auto auto 14px;
      width: min(520px, calc(100% - 28px));
      display: none;
      pointer-events: auto;
    }
    #help h2 { margin: 0 0 8px 0; font-size: 14px; }
    #help ul { margin: 6px 0 0 18px; padding: 0; }
    #help li { margin: 6px 0; }

    /* Checkbox */
    .chk { display:flex; align-items:center; gap:8px; }
    .chk input { width: 16px; height: 16px; cursor: pointer; }

    /* Canvas helpers */
    #centerGuide { position:absolute; left:50%; top:50%; width:24px; height:24px; transform: translate(-50%,-50%); pointer-events:none; opacity:0.35; filter: drop-shadow(0 0 6px rgba(111,194,255,0.8)); }
    #centerGuide svg { width: 100%; height: 100%; }
  </style>
</head>
<body>
<div id="app">
  <div id="canvasWrap"></div>
  <div id="centerGuide" aria-hidden="true">
    <svg viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="10" stroke="#6fc2ff" stroke-width="2" fill="none"/>
      <circle cx="12" cy="12" r="2" fill="#9effff"/>
    </svg>
  </div>

  <div id="toast"></div>

  <div id="hud">
    <div class="panel" id="leftPanel">
      <div class="titleRow">
        <h1>TEKS Nuclear Lab</h1>
        <div class="row">
          <span class="pill" id="xpPill">‚≠ê XP 0</span>
          <button id="toggleHelpBtn" title="What is this simulation?" style="pointer-events:auto;">‚ùî</button>
        </div>
      </div>
      <div class="stepCard" id="step1">
        <span class="stepLabel"><span class="icon">üéØ</span>Step 1 ¬∑ Pick a mission</span>
        <span class="stepHint">Tap a mission card to load a preset nucleus for that process.</span>
        <div id="missionList"></div>
      </div>

      <div class="stepCard locked" id="step2">
        <span class="stepLabel"><span class="icon">üß¨</span>Step 2 ¬∑ Prep the nucleus</span>
        <span class="stepHint">Use Sandbox to swap isotopes or keep the mission default.</span>
        <div class="kv" style="margin-bottom: 8px;">
          <div>
            <div class="k">Current nucleus</div>
            <div class="v" id="nuclideReadout">‚Äî</div>
          </div>
          <div>
            <div class="k">Stability hint</div>
            <div class="v" id="stabilityReadout">‚Äî</div>
          </div>
        </div>
        <div class="row" style="margin-bottom: 8px;">
          <label class="small muted" title="Load a suggested isotope pair or single nucleus.">Sandbox:</label>
          <select id="sandboxIsotope">
            <option value="84,126">Po-210 (Œ±)</option>
            <option value="6,8">C-14 (Œ≤-)</option>
            <option value="27,33">Co-60 (Œ≥)</option>
            <option value="92,143">U-235 (fission)</option>
            <option value="1,1|1,2">H-2 + H-3 (fusion)</option>
          </select>
          <button id="loadSandboxBtn" title="Load sandbox selection">‚èé</button>
          <button id="resetBtn" title="Reset scores">üîÑ</button>
        </div>
        <div class="chipRow">
          <span class="chip"><span class="dot proton"></span>p‚Å∫ proton</span>
          <span class="chip"><span class="dot neutron"></span>n‚Å∞ neutron</span>
          <span class="chip"><span class="dot beta"></span>Œ≤‚Åª</span>
          <span class="chip"><span class="dot gamma"></span>Œ≥ photon</span>
        </div>
      </div>

      <div class="stepCard locked" id="step3">
        <span class="stepLabel"><span class="icon">‚ö°</span>Step 3 ¬∑ Run the reaction</span>
        <span class="stepHint">Buttons unlock after you load a nucleus.</span>
        <div class="row" style="margin-bottom: 10px;">
          <button id="alphaBtn" title="Alpha decay">üõ°Ô∏è Œ±</button>
          <button id="betaBtn" title="Beta minus">‚ö° Œ≤‚Åª</button>
          <button id="gammaBtn" title="Gamma emission">‚ú® Œ≥</button>
          <button id="fissionBtn" title="Nuclear fission">‚ò¢Ô∏è</button>
          <button id="fusionBtn" title="Nuclear fusion">üîó</button>
        </div>
        <div class="row" style="margin-bottom: 6px;">
          <label class="chk small muted" title="Hides element symbols in the equation blanks to make balancing less guided.">
            <input id="challengeToggle" type="checkbox" />
            Challenge mode (hide symbols)
          </label>
        </div>
      </div>

      <div class="small muted" style="margin-bottom: 4px;">
        Reveal steps in order: Mission ‚Üí Prep nucleus ‚Üí Reaction ‚Üí Balance.
      </div>
    </div>

    <div class="panel" id="rightPanel">
      <div class="titleRow">
        <h1>Mission Control</h1>
        <span class="pill" id="badgePill">Badges 0</span>
      </div>

      <div class="small" id="missionStatus">
        Select a mission. Use the action buttons to perform the reaction, then balance the equation.
      </div>

      <hr style="border: none; border-top: 1px solid rgba(255,255,255,0.12); margin: 10px 0;" />

      <div class="kv">
        <div>
          <div class="k">Energy Meter</div>
          <div class="v" id="energyReadout">0</div>
        </div>
        <div>
          <div class="k">Safety Meter</div>
          <div class="v" id="safetyReadout">100</div>
        </div>
      </div>

      <div style="height: 10px;"></div>

      <div class="small muted">
        Scoring: +XP for correct balancing; +Energy for correct reaction type; Safety drops if you try the wrong reaction for a mission.
      </div>

      <div class="chipRow" style="margin-top:10px;">
        <span class="chip"><span class="dot proton"></span>Proton (p‚Å∫)</span>
        <span class="chip"><span class="dot neutron"></span>Neutron (n‚Å∞)</span>
        <span class="chip"><span class="dot beta"></span>Œ≤‚Åª particle</span>
        <span class="chip"><span class="dot gamma"></span>Œ≥ photon</span>
      </div>
    </div>
  </div>

  <div id="help" class="panel">
    <div class="titleRow">
      <h1>Help</h1>
      <button id="closeHelpBtn">Close</button>
    </div>
    <div class="small">
      <h2>How to use</h2>
      <ul>
        <li>Pick a mission (left panel). It will tell you the target process.</li>
        <li>Click the matching reaction button (Œ±, Œ≤‚Åª, Œ≥, fission, fusion).</li>
        <li>Then balance the nuclear equation in the bottom panel and submit (press Enter in a blank).</li>
        <li>Use ‚ÄúSandbox isotope‚Äù if you want to explore freely.</li>
      </ul>
      <h2>Safety note</h2>
      <div class="muted">
        This simulator is conceptual and does not model engineering details (reactor design, enrichment, critical mass, etc.).
      </div>
    </div>
  </div>

  <div id="bottomBar">
    <div class="panel" id="equationPanel">
      <div class="titleRow">
        <h1>Step 4 ¬∑ ‚öñÔ∏è Balance the nuclear equation</h1>
        <span class="pill" id="equationHint">‚Äî</span>
      </div>
      <div id="equation" class="small muted">
        Start a mission or run a reaction to see an equation to balance.
      </div>
      <div class="row" style="margin-top: 10px;">
        <button id="checkEqBtn" disabled>Check & Submit</button>
        <button id="hintBtn" disabled>Hint (-10 XP)</button>
        <span class="small muted" id="feedback"></span>
      </div>
    </div>
  </div>
</div>

<script type="module">

import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

/* ---------- Utilities ---------- */
const periodic = [
  "", "H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca",
  "Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr",
  "Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd",
  "Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg",
  "Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U"
];
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

function showToast(msg) {
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(() => t.classList.remove("show"), 2200);
}

function nuclideLabel(Z, N) {
  const A = Z + N;
  const sym = periodic[Z] ?? `Z${Z}`;
  return `${sym}-${A}`;
}

/* ---------- TEKS-aligned Missions ---------- */
const missions = [
  { id: "M1", title: "Alpha decay balancing", tag: "112.43(c)(14)(A)", desc: "Describe alpha decay using a balanced nuclear equation (A and Z must be conserved).", type: "alpha", start: { Z: 84, N: 126 } },
  { id: "M2", title: "Beta (Œ≤‚Åª) decay balancing", tag: "112.43(c)(14)(A)", desc: "Describe beta decay using a balanced nuclear equation (a neutron becomes a proton).", type: "beta", start: { Z: 6, N: 8 } },
  { id: "M3", title: "Gamma emission", tag: "112.43(c)(14)(A)", desc: "Gamma emission changes energy state but not A or Z. Show it with a nuclear equation.", type: "gamma", start: { Z: 27, N: 33 } },
  { id: "M4", title: "Fission vs fusion", tag: "112.43(c)(14)(B)", desc: "Run a fission reaction for U-235 and compare with fusion behavior.", type: "fission", start: { Z: 92, N: 143 } },
  { id: "M5", title: "Fusion reaction", tag: "112.43(c)(14)(B)", desc: "Run fusion: deuterium + tritium ‚Üí helium-4 + neutron.", type: "fusion", start: { pair: [{Z:1,N:1},{Z:1,N:2}] } },
  { id: "M6", title: "Applications decision", tag: "112.43(c)(14)(C)", desc: "Choose an application for the radiation type and justify it (therapy vs imaging vs power).", type: "applications", start: { Z: 6, N: 8 } }
];

/* ---------- Game State ---------- */
const state = {
  xp: 0, badges: 0, energy: 0, safety: 100,
  currentMission: null,
  current: { Z: 6, N: 6 },
  currentPair: null,
  challenge: false,
  stepLevel: 1
};
const missionListEl = document.getElementById("missionList");
const missionStatusEl = document.getElementById("missionStatus");

function addXP(delta) { state.xp = Math.max(0, state.xp + delta); document.getElementById("xpPill").textContent = `‚≠ê XP ${state.xp}`; }
function addBadge() { state.badges += 1; document.getElementById("badgePill").textContent = `Badges ${state.badges}`; }
function updateMeters() { document.getElementById("energyReadout").textContent = state.energy.toFixed(0); document.getElementById("safetyReadout").textContent = state.safety.toFixed(0); }

function stabilityHeuristic(Z, N) {
  const ratio = N / Math.max(1, Z);
  const A = Z + N;
  const target = A < 20 ? 1.0 : (A < 80 ? 1.25 : 1.5);
  const d = Math.abs(ratio - target);
  if (d < 0.12) return "Likely stable";
  if (d < 0.25) return "Borderline";
  return "Unstable";
}

function updateNuclideReadout() {
  if (state.currentPair) {
    const a = state.currentPair[0], b = state.currentPair[1];
    document.getElementById("nuclideReadout").textContent = `${nuclideLabel(a.Z,a.N)} + ${nuclideLabel(b.Z,b.N)}`;
    document.getElementById("stabilityReadout").textContent = "‚Äî";
    return;
  }
  document.getElementById("nuclideReadout").textContent = nuclideLabel(state.current.Z, state.current.N);
  document.getElementById("stabilityReadout").textContent = stabilityHeuristic(state.current.Z, state.current.N);
}

function setStepLevel(level) {
  state.stepLevel = level;
  const s2 = document.getElementById("step2");
  const s3 = document.getElementById("step3");
  s2.classList.toggle("locked", level < 2);
  s3.classList.toggle("locked", level < 3);
  const actionButtons = ["alphaBtn","betaBtn","gammaBtn","fissionBtn","fusionBtn"].map(id => document.getElementById(id));
  actionButtons.forEach(btn => btn.disabled = level < 3);
  if (!state.currentMission) {
    if (level < 2) missionStatusEl.textContent = "Step 1: Pick a mission card to unlock the nucleus and reactions.";
    if (level === 2) missionStatusEl.textContent = "Step 2: Adjust the nucleus or keep defaults, then trigger a reaction.";
  }
}

/* ---------- Three.js Scene ---------- */
const wrap = document.getElementById("canvasWrap");
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0b1020, 10, 36);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 2.8, 8.8);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
renderer.setSize(window.innerWidth, window.innerHeight);
wrap.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = 6;
controls.maxDistance = 22;

scene.add(new THREE.HemisphereLight(0xbcd6ff, 0x203060, 0.85));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(6, 10, 4);
scene.add(dir);

const grid = new THREE.GridHelper(40, 40, 0x223355, 0x18223b);
grid.position.y = -3.2;
grid.material.opacity = 0.5;
grid.material.transparent = true;
scene.add(grid);
const coreLight = new THREE.PointLight(0x6fc2ff, 1.35, 18);
coreLight.position.set(0, 0, 0);
scene.add(coreLight);

const nucleusGroup = new THREE.Group(); scene.add(nucleusGroup);
const extraGroup = new THREE.Group(); scene.add(extraGroup);

const protonMat = new THREE.MeshStandardMaterial({ color: 0xff4766, roughness: 0.32, metalness: 0.08 });
const neutronMat = new THREE.MeshStandardMaterial({ color: 0xc7d0df, roughness: 0.38, metalness: 0.08 });
const glowMat = new THREE.MeshStandardMaterial({ color: 0x6fc2ff, emissive: 0x0b2a55, emissiveIntensity: 1.0 });
const particleGeom = new THREE.SphereGeometry(0.18, 18, 18);
const nucleonGeom = new THREE.SphereGeometry(0.28, 18, 18);
const labelCache = new Map();

function makeLabelSprite(text, color = "#e9eefc", bg = "rgba(18,32,64,0.9)") {
  const key = `${text}-${color}-${bg}`;
  if (labelCache.has(key)) return labelCache.get(key).clone();
  const canvas = document.createElement("canvas");
  canvas.width = 256; canvas.height = 128;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = bg;
  const rx = 10, ry = 36, rw = canvas.width - 20, rh = 56, rad = 18;
  ctx.beginPath();
  ctx.moveTo(rx + rad, ry);
  ctx.lineTo(rx + rw - rad, ry);
  ctx.quadraticCurveTo(rx + rw, ry, rx + rw, ry + rad);
  ctx.lineTo(rx + rw, ry + rh - rad);
  ctx.quadraticCurveTo(rx + rw, ry + rh, rx + rw - rad, ry + rh);
  ctx.lineTo(rx + rad, ry + rh);
  ctx.quadraticCurveTo(rx, ry + rh, rx, ry + rh - rad);
  ctx.lineTo(rx, ry + rad);
  ctx.quadraticCurveTo(rx, ry, rx + rad, ry);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.35)"; ctx.stroke();
  ctx.font = "42px 'Inter', 'Arial'";
  ctx.fillStyle = color;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 10);
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(1.2, 0.6, 1);
  labelCache.set(key, sprite);
  return sprite;
}

function attachLabel(obj, text, color = "#9effff") {
  if (!text) return null;
  const sprite = makeLabelSprite(text, color);
  sprite.position.set(0, 0.55, 0);
  obj.add(sprite);
  return sprite;
}

let anim = { t: 0, mode: "idle", payload: null };

function clearGroups() {
  while (nucleusGroup.children.length) nucleusGroup.remove(nucleusGroup.children[0]);
  while (extraGroup.children.length) extraGroup.remove(extraGroup.children[0]);
}

function packPositions(count, radius) {
  const pts = [];
  const maxTries = 4000;
  let tries = 0;
  while (pts.length < count && tries < maxTries) {
    tries++;
    const p = new THREE.Vector3((Math.random()*2-1),(Math.random()*2-1),(Math.random()*2-1))
      .normalize().multiplyScalar(Math.random() * radius);
    let ok = true;
    for (const q of pts) if (p.distanceTo(q) < 0.50) { ok = false; break; }
    if (ok) pts.push(p);
  }
  while (pts.length < count) {
    pts.push(new THREE.Vector3((Math.random()*2-1),(Math.random()*2-1),(Math.random()*2-1))
      .normalize().multiplyScalar(Math.random() * radius));
  }
  return pts;
}

function buildSingleNucleus(Z, N) {
  clearGroups();
  const A = Z + N;
  const radius = 0.62 + 0.045 * Math.pow(A, 0.55);
  const positions = packPositions(A, radius);

  for (let i = positions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }

  for (let i = 0; i < A; i++) {
    const isProton = i < Z;
    const m = new THREE.Mesh(nucleonGeom, isProton ? protonMat : neutronMat);
    m.position.copy(positions[i]);
    nucleusGroup.add(m);
  }

  const shell = new THREE.Mesh(
    new THREE.SphereGeometry(radius * 1.25, 22, 22),
    new THREE.MeshStandardMaterial({ color: 0x1a2f66, emissive: 0x0b2a55, emissiveIntensity: 1.0, transparent: true, opacity: 0.25, roughness: 0.9 })
  );
  nucleusGroup.add(shell);
  const core = new THREE.Mesh(new THREE.SphereGeometry(radius * 0.35, 18, 18), new THREE.MeshBasicMaterial({ color: 0x9effff, transparent:true, opacity:0.35 }));
  nucleusGroup.add(core);
  const anchor = new THREE.Object3D();
  anchor.position.set(0, radius * 1.25 + 0.45, 0);
  nucleusGroup.add(anchor);
  attachLabel(anchor, `${nuclideLabel(Z,N)} | Z=${Z}`, "#9effff");
}

function buildFusionPair(a, b) {
  clearGroups();
  const left = new THREE.Group();
  const right = new THREE.Group();
  nucleusGroup.add(left); nucleusGroup.add(right);

  function populate(g, Z, N) {
    const A = Z + N;
    const r = 0.5 + 0.06 * Math.pow(A, 0.55);
    const positions = packPositions(A, r);
    for (let i = 0; i < A; i++) {
      const isProton = i < Z;
      const m = new THREE.Mesh(nucleonGeom, isProton ? protonMat : neutronMat);
      m.position.copy(positions[i]);
      g.add(m);
    }
    const shell = new THREE.Mesh(
      new THREE.SphereGeometry(r * 1.35, 18, 18),
      new THREE.MeshStandardMaterial({ color: 0x1a2f66, emissive: 0x0b2a55, emissiveIntensity: 0.8, transparent:true, opacity:0.18 })
    );
    g.add(shell);
    const anchor = new THREE.Object3D();
    anchor.position.set(0, r * 1.35 + 0.35, 0);
    g.add(anchor);
    attachLabel(anchor, `${nuclideLabel(Z,N)} | Z=${Z}`, "#6fc2ff");
  }

  populate(left, a.Z, a.N);
  populate(right, b.Z, b.N);
  left.position.set(-2.4, 0, 0);
  right.position.set(2.4, 0, 0);
}

function setSceneToCurrent() {
  if (state.currentPair) buildFusionPair(state.currentPair[0], state.currentPair[1]);
  else buildSingleNucleus(state.current.Z, state.current.N);
  updateNuclideReadout();
}

/* ---------- Conceptual nuclear processes ---------- */
function doAlphaDecay(before) { return { after: { Z: before.Z - 2, N: before.N - 2 } }; }
function doBetaMinus(before) { return { after: { Z: before.Z + 1, N: before.N - 1 } }; }
function doFusion(pair) { return { after: { Z: 2, N: 2 }, extras: { reactants: [pair[0], pair[1]] } }; }

/* ---------- Animations ---------- */
function spawnParticle(material, start, end, scale=1.0, labelText="", labelColor="#e9eefc") {
  const m = new THREE.Mesh(particleGeom, material);
  m.scale.setScalar(scale);
  m.position.copy(start);
  if (labelText) attachLabel(m, labelText, labelColor);
  extraGroup.add(m);
  return { mesh: m, start: start.clone(), end: end.clone() };
}

function startAnimation(kind) {
  while (extraGroup.children.length) extraGroup.remove(extraGroup.children[0]);
  anim = { t: 0, mode: kind, payload: { particles: [] } };
  if (kind === "alpha") {
    anim.payload.particles.push(
      spawnParticle(protonMat, new THREE.Vector3(0,0,0), new THREE.Vector3(4,1.2,0), 1.25, "p‚Å∫", "#ff8da3"),
      spawnParticle(neutronMat, new THREE.Vector3(0.2,0.1,0), new THREE.Vector3(4.4,1.0,0.2), 1.25, "n‚Å∞", "#d6deed"),
      spawnParticle(neutronMat, new THREE.Vector3(-0.2,0.0,0), new THREE.Vector3(4.2,0.9,-0.2), 1.25, "n‚Å∞", "#d6deed"),
      spawnParticle(protonMat, new THREE.Vector3(0.1,-0.1,0), new THREE.Vector3(4.6,1.1,-0.1), 1.25, "p‚Å∫", "#ff8da3")
    );
  } else if (kind === "beta") {
    anim.payload.particles.push(spawnParticle(glowMat, new THREE.Vector3(0,0,0), new THREE.Vector3(4, 0.5, 0.8), 0.9, "Œ≤‚Åª", "#6fc2ff"));
  } else if (kind === "gamma") {
    const gMat = new THREE.MeshStandardMaterial({ color: 0x9effff, emissive: 0x2a9fb0, emissiveIntensity: 1.5 });
    anim.payload.particles.push(spawnParticle(gMat, new THREE.Vector3(0,0,0), new THREE.Vector3(5, 0, 0), 0.7, "Œ≥", "#9effff"));
  } else if (kind === "fission") {
    showToast("Fission: nucleus splits + releases neutrons (conceptual).");
    anim.payload.particles.push(
      spawnParticle(neutronMat, new THREE.Vector3(0,0,0), new THREE.Vector3(-5, 0.6, 0.2), 1.0, "n‚Å∞", "#d6deed"),
      spawnParticle(neutronMat, new THREE.Vector3(0,0,0), new THREE.Vector3(5, -0.3, -0.1), 1.0, "n‚Å∞", "#d6deed"),
      spawnParticle(neutronMat, new THREE.Vector3(0,0,0), new THREE.Vector3(3.6, 0.2, 0.6), 1.0, "n‚Å∞", "#d6deed")
    );
  } else if (kind === "fusion") {
    showToast("Fusion: two nuclei merge (conceptual).");
  }
}

function easeOutCubic(x){ return 1 - Math.pow(1-x,3); }
function easeInOut(x){ return x < 0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2; }

function animateFrame(dt) {
  anim.t += dt;
  const t = anim.t;
  const p = anim.payload || {};

  if (anim.mode === "alpha" || anim.mode === "beta" || anim.mode === "gamma") {
    const k = clamp(t / 1.2, 0, 1);
    for (const part of (p.particles || [])) part.mesh.position.lerpVectors(part.start, part.end, easeOutCubic(k));
    if (k >= 1 && t > 1.35) anim.mode = "idle";
  }

  if (anim.mode === "fusion") {
    const k = clamp(t / 1.6, 0, 1);
    const left = nucleusGroup.children[0];
    const right = nucleusGroup.children[1];
    if (left && right) {
      left.position.lerpVectors(new THREE.Vector3(-2.4,0,0), new THREE.Vector3(-0.4,0,0), easeInOut(k));
      right.position.lerpVectors(new THREE.Vector3(2.4,0,0), new THREE.Vector3(0.4,0,0), easeInOut(k));
    }
    if (k >= 1 && t > 1.7) anim.mode = "idle";
  }
}

/* ---------- Equation Builder / Checker ---------- */
const eqEl = document.getElementById("equation");
const eqHintEl = document.getElementById("equationHint");
const feedbackEl = document.getElementById("feedback");
const checkBtn = document.getElementById("checkEqBtn");
const hintBtn = document.getElementById("hintBtn");

let eqModel = null;
let lastEqReaction = null;

function symFor(Z) { return state.challenge ? "?" : (periodic[Z] ?? `Z${Z}`); }

function nuclideSpan({Z,N}, allowBlank=false, idPrefix="") {
  const A = Z + N;
  const sym = symFor(Z);
  const AHtml = allowBlank ? `<input class="blank" id="${idPrefix}A" inputmode="numeric" placeholder="A" />` : `<span class="A">${A}</span>`;
  const ZHtml = allowBlank ? `<input class="blank" id="${idPrefix}Z" inputmode="numeric" placeholder="Z" />` : `<span class="Z">${Z}</span>`;
  return `<span class="nuclide">${AHtml}${ZHtml}<span class="sym">${sym}</span></span>`;
}

function setEquationForReaction(reaction) {
  lastEqReaction = reaction;
  feedbackEl.textContent = "";
  eqHintEl.textContent = reaction.hint ?? "Conserve mass number (A) and atomic number (Z)";
  checkBtn.disabled = false;
  hintBtn.disabled = false;

  const kind = reaction.kind;
  if (kind === "alpha") {
    const before = reaction.before, after = reaction.after;
    eqModel = { kind, expected: { afterA: after.Z+after.N, afterZ: after.Z } };
    eqEl.innerHTML = `${nuclideSpan(before)} ‚Üí ${nuclideSpan(after, true, "d_")} + ${nuclideSpan({Z:2,N:2})} (Œ±)`;
  } else if (kind === "beta") {
    const before = reaction.before, after = reaction.after;
    eqModel = { kind, expected: { afterA: after.Z+after.N, afterZ: after.Z } };
    eqEl.innerHTML =
      `${nuclideSpan(before)} ‚Üí ${nuclideSpan(after, true, "d_")} + <span class="nuclide"><span class="A">0</span><span class="Z">-1</span><span class="sym">e</span></span> (Œ≤‚Åª)`;
  } else if (kind === "gamma") {
    const before = reaction.before;
    eqModel = { kind, expected: { afterA: before.Z+before.N, afterZ: before.Z } };
    const leftSym = symFor(before.Z);
    eqEl.innerHTML =
      `<span class="nuclide"><input class="blank" id="d_A" inputmode="numeric" placeholder="A" /><input class="blank" id="d_Z" inputmode="numeric" placeholder="Z" /><span class="sym">${leftSym}</span></span>` +
      ` ‚Üí ${nuclideSpan(before)} + <span class="sym">Œ≥</span>`;
  } else if (kind === "fusion") {
    const [a,b] = reaction.reactants;
    eqModel = { kind, expected: {} };
    const heSym = state.challenge ? "?" : "He";
    eqEl.innerHTML =
      `${nuclideSpan(a)} + ${nuclideSpan(b)} ‚Üí ` +
      `<span class="nuclide"><input class="blank" id="p_A" inputmode="numeric" placeholder="A" /><input class="blank" id="p_Z" inputmode="numeric" placeholder="Z" /><span class="sym">${heSym}</span></span>` +
      ` + <span class="nuclide"><input class="blank" id="n_A" inputmode="numeric" placeholder="A" /><input class="blank" id="n_Z" inputmode="numeric" placeholder="Z" /><span class="sym">n</span></span>`;
  } else if (kind === "fission") {
    eqModel = { kind, expected: { neutrons: 3 } };
    eqEl.innerHTML =
      `<span class="small">Balance the neutron count:</span><br/>` +
      `${nuclideSpan({Z:92,N:143})} + <span class="nuclide"><span class="A">1</span><span class="Z">0</span><span class="sym">n</span></span> ‚Üí ` +
      `${nuclideSpan({Z:56,N:85})} + ${nuclideSpan({Z:36,N:56})} + ` +
      `<input class="blank" id="k_n" inputmode="numeric" placeholder="n?" />` +
      `<span class="nuclide"><span class="A">1</span><span class="Z">0</span><span class="sym">n</span></span>`;
  } else if (kind === "applications") {
    eqModel = { kind, expected: {} };
    eqEl.innerHTML =
      `<div class="small">Pick a best-fit application:</div>
       <div class="row" style="margin-top:8px;">
         <select id="appPick">
           <option value="">Choose‚Ä¶</option>
           <option value="alpha">Œ±: smoke detectors / high ionization (shielded)</option>
           <option value="beta">Œ≤‚Åª: thickness gauge / some tracers</option>
           <option value="gamma">Œ≥: diagnostic imaging / therapy (high penetration)</option>
           <option value="fission">Fission: nuclear power (electricity)</option>
           <option value="fusion">Fusion: stars (energy source)</option>
         </select>
         <input id="appWhy" style="width: min(360px, 100%);" placeholder="One-sentence justification‚Ä¶" />
       </div>`;
  }
}

function scoreResult(ok, msg) {
  feedbackEl.textContent = msg;
  if (ok) {
    addXP(40);
    state.energy += 25;
    state.safety = clamp(state.safety + 2, 0, 100);
    updateMeters();
    if (state.currentMission && !state.currentMission.completed) {
      state.currentMission.completed = true;
      addBadge();
      showToast(`Mission complete: ${state.currentMission.title}`);
      renderMissions();
      setActionLocks(null);
    } else showToast("Correct!");
  } else {
    state.safety = clamp(state.safety - 6, 0, 100);
    updateMeters();
    addXP(-5);
    showToast("Try again.");
  }
}

function checkEquation() {
  if (!eqModel) return;

  if (eqModel.kind === "alpha" || eqModel.kind === "beta") {
    const A = parseInt(document.getElementById("d_A")?.value, 10);
    const Z = parseInt(document.getElementById("d_Z")?.value, 10);
    const ok = (A === eqModel.expected.afterA) && (Z === eqModel.expected.afterZ);
    scoreResult(ok, ok ? "Correct. A and Z are conserved." : "Not yet. Check that A and Z are conserved.");
    return;
  }

  if (eqModel.kind === "gamma") {
    const A = parseInt(document.getElementById("d_A")?.value, 10);
    const Z = parseInt(document.getElementById("d_Z")?.value, 10);
    const ok = (A === eqModel.expected.afterA) && (Z === eqModel.expected.afterZ);
    scoreResult(ok, ok ? "Correct. Œ≥ emission does not change A or Z." : "Not yet. Œ≥ emission keeps A and Z the same.");
    return;
  }

  if (eqModel.kind === "fusion") {
    const pA = parseInt(document.getElementById("p_A")?.value, 10);
    const pZ = parseInt(document.getElementById("p_Z")?.value, 10);
    const nA = parseInt(document.getElementById("n_A")?.value, 10);
    const nZ = parseInt(document.getElementById("n_Z")?.value, 10);
    const ok = (pA===4 && pZ===2 && nA===1 && nZ===0);
    scoreResult(ok, ok ? "Correct. Fusion conserves A and Z." : "Not yet. Try He-4 plus one neutron.");
    return;
  }

  if (eqModel.kind === "fission") {
    const k = parseInt(document.getElementById("k_n")?.value, 10);
    const ok = (k === eqModel.expected.neutrons);
    scoreResult(ok, ok ? "Correct. Neutron count balances the mass numbers." : "Not yet. Re-check A totals on each side.");
    return;
  }

  if (eqModel.kind === "applications") {
    const pick = document.getElementById("appPick")?.value;
    const why = (document.getElementById("appWhy")?.value || "").trim();
    const ok = !!pick && why.length >= 10;
    scoreResult(ok, ok ? "Good. You connected a nuclear phenomenon to a real application." : "Add a choice and a brief justification (‚â•10 characters).");
  }
}

function showHint() {
  if (!eqModel) return;
  addXP(-10);
  if (eqModel.kind === "alpha") showToast("Alpha decay: A decreases by 4, Z decreases by 2.");
  else if (eqModel.kind === "beta") showToast("Œ≤‚Åª decay: A stays same; Z increases by 1.");
  else if (eqModel.kind === "gamma") showToast("Œ≥ emission: A and Z do not change.");
  else if (eqModel.kind === "fusion") showToast("D+T fusion makes He-4 and a neutron.");
  else if (eqModel.kind === "fission") showToast("Total A must match. U-235 + 1 = 236 on the left.");
  else showToast("Use: penetration (Œ≥ > Œ≤ > Œ±), and common uses (therapy/imaging/power).");
}

/* ---------- Missions ---------- */
function renderMissions() {
  missionListEl.innerHTML = "";
  for (const m of missions) {
    const div = document.createElement("div");
    div.className = "mission";
    div.innerHTML = `
      <div class="missionHeader">
        <div class="name">${m.title}</div>
        <div class="tag">${m.tag}</div>
      </div>
      <div class="desc">${m.desc}</div>
      <div class="actions">
        <button data-mid="${m.id}">${m.completed ? "Review" : "Start"}</button>
        <span class="pill">${m.completed ? "‚úì Done" : "Not done"}</span>
      </div>
    `;
    div.querySelector("button").addEventListener("click", () => startMission(m.id));
    missionListEl.appendChild(div);
  }
}

function setActionLocks(type) {
  const alphaBtn = document.getElementById("alphaBtn");
  const betaBtn = document.getElementById("betaBtn");
  const gammaBtn = document.getElementById("gammaBtn");
  const fissionBtn = document.getElementById("fissionBtn");
  const fusionBtn = document.getElementById("fusionBtn");

  [alphaBtn,betaBtn,gammaBtn,fissionBtn,fusionBtn].forEach(b => b.disabled = false);

  if (state.stepLevel < 3) {
    [alphaBtn,betaBtn,gammaBtn,fissionBtn,fusionBtn].forEach(b => b.disabled = true);
    return;
  }

  if (!type) return;
  if (!state.currentMission || state.currentMission.completed) return;

  [alphaBtn,betaBtn,gammaBtn,fissionBtn,fusionBtn].forEach(b => b.disabled = true);

  if (type === "alpha") alphaBtn.disabled = false;
  if (type === "beta") betaBtn.disabled = false;
  if (type === "gamma") gammaBtn.disabled = false;
  if (type === "fission") fissionBtn.disabled = false;
  if (type === "fusion") fusionBtn.disabled = false;
  if (type === "applications") {
    [alphaBtn,betaBtn,gammaBtn,fissionBtn,fusionBtn].forEach(b => b.disabled = false);
    setEquationForReaction({ kind: "applications", hint: "Explain why the radiation/process fits the application" });
  }
}

function startMission(mid) {
  const m = missions.find(x => x.id === mid);
  if (!m) return;
  state.currentMission = m;
  missionStatusEl.textContent = `Active mission: ${m.title} (${m.tag}). ${m.desc}`;

  if (m.type === "fusion") { state.currentPair = m.start.pair; state.current = { Z: 0, N: 0 }; }
  else { state.currentPair = null; state.current = m.start; }

  setSceneToCurrent();
  setStepLevel(2);

  eqModel = null; lastEqReaction = null;
  eqEl.textContent = (m.type === "applications") ? "Complete the application choice below." : "Run the required reaction button, then balance the equation.";
  eqHintEl.textContent = "‚Äî"; feedbackEl.textContent = "";
  checkBtn.disabled = true; hintBtn.disabled = true;

  setActionLocks(m.type);
  showToast(`Mission started: ${m.title}`);
}

/* ---------- Actions ---------- */
function ensureMissionMatch(kind) {
  if (!state.currentMission || state.currentMission.completed) return true;
  const expected = state.currentMission.type;
  if (expected === kind) return true;
  state.safety = clamp(state.safety - 10, 0, 100);
  updateMeters();
  showToast("Wrong reaction for this mission. Read the mission prompt.");
  return false;
}

function runAlpha() {
  if (!state.currentPair && state.current.Z >= 2 && state.current.N >= 2) {
    if (!ensureMissionMatch("alpha")) return;
    const before = { ...state.current };
    const r = doAlphaDecay(before);
    state.current = r.after;
    setSceneToCurrent();
    setStepLevel(3);
    startAnimation("alpha");
    setEquationForReaction({ kind: "alpha", before, after: r.after, hint: "Alpha: A‚àí4, Z‚àí2" });
    state.energy += 10; updateMeters();
  } else showToast("Load a heavy nuclide (Sandbox) for alpha decay.");
}

function runBeta() {
  if (!state.currentPair && state.current.N >= 1) {
    if (!ensureMissionMatch("beta")) return;
    const before = { ...state.current };
    const r = doBetaMinus(before);
    state.current = r.after;
    setSceneToCurrent();
    setStepLevel(3);
    startAnimation("beta");
    setEquationForReaction({ kind: "beta", before, after: r.after, hint: "Œ≤‚Åª: A same, Z+1" });
    state.energy += 8; updateMeters();
  } else showToast("Load a single nuclide (not a fusion pair) for Œ≤‚Åª decay.");
}

function runGamma() {
  if (!state.currentPair) {
    if (!ensureMissionMatch("gamma")) return;
    const before = { ...state.current };
    setStepLevel(3);
    startAnimation("gamma");
    setEquationForReaction({ kind: "gamma", before, after: before, hint: "Œ≥: A and Z unchanged" });
    state.energy += 5; updateMeters();
  } else showToast("Gamma emission is shown on a single nucleus. Load a single nuclide.");
}

function runFusion() {
  if (state.currentPair) {
    if (!ensureMissionMatch("fusion")) return;
    const r = doFusion(state.currentPair);
    state.currentPair = null;
    state.current = r.after;
    setSceneToCurrent();
    setStepLevel(3);
    startAnimation("fusion");
    setEquationForReaction({ kind: "fusion", reactants: r.extras.reactants, hint: "D+T ‚Üí He-4 + n" });
    state.energy += 18; updateMeters();
  } else showToast("Load the fusion pair (H-2 + H-3) from Sandbox.");
}

function runFission() {
  if (!state.currentPair && state.current.Z === 92) {
    if (!ensureMissionMatch("fission")) return;
    setStepLevel(3);
    startAnimation("fission");
    setEquationForReaction({ kind: "fission", hint: "U-235 + n ‚Üí Ba-141 + Kr-92 + 3n" });
    state.energy += 20; updateMeters();
  } else showToast("Load U-235 from Sandbox to run fission.");
}

/* ---------- Sandbox loading ---------- */
function loadSandboxSelection() {
  const v = document.getElementById("sandboxIsotope").value;
  if (v.includes("|")) {
    const [a,b] = v.split("|").map(s => s.split(",").map(Number));
    state.currentPair = [{Z:a[0], N:a[1]}, {Z:b[0], N:b[1]}];
    state.current = { Z: 0, N: 0 };
  } else {
    const [Z,N] = v.split(",").map(Number);
    state.currentPair = null;
    state.current = { Z, N };
  }
  state.currentMission = null;
  setSceneToCurrent();
  setStepLevel(2);
  eqModel = null; lastEqReaction = null;
  eqEl.textContent = "Sandbox loaded. Run a reaction to generate an equation.";
  eqHintEl.textContent = "‚Äî"; feedbackEl.textContent = "";
  checkBtn.disabled = true; hintBtn.disabled = true;
  missionStatusEl.textContent = "Sandbox mode. Select a mission if you want guided scaffolds and scoring.";
  setActionLocks(null);
}

/* ---------- Wiring ---------- */
document.getElementById("alphaBtn").addEventListener("click", runAlpha);
document.getElementById("betaBtn").addEventListener("click", runBeta);
document.getElementById("gammaBtn").addEventListener("click", runGamma);
document.getElementById("fissionBtn").addEventListener("click", runFission);
document.getElementById("fusionBtn").addEventListener("click", runFusion);

document.getElementById("loadSandboxBtn").addEventListener("click", loadSandboxSelection);

document.getElementById("resetBtn").addEventListener("click", () => {
  state.xp = 0; state.badges = 0; state.energy = 0; state.safety = 100;
  missions.forEach(m => delete m.completed);
  addXP(0);
  document.getElementById("badgePill").textContent = "Badges 0";
  updateMeters();
  setStepLevel(1);
  loadSandboxSelection();
  renderMissions();
  showToast("Reset complete.");
});

document.getElementById("challengeToggle").addEventListener("change", (e) => {
  state.challenge = !!e.target.checked;
  showToast(state.challenge ? "Challenge mode ON (symbols hidden)." : "Challenge mode OFF (symbols shown).");
  if (lastEqReaction) setEquationForReaction(lastEqReaction);
});

document.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !checkBtn.disabled) {
    const tag = (document.activeElement?.tagName || "").toLowerCase();
    if (tag === "input") checkEquation();
  }
});

checkBtn.addEventListener("click", checkEquation);
hintBtn.addEventListener("click", showHint);

/* Help drawer */
const help = document.getElementById("help");
document.getElementById("toggleHelpBtn").addEventListener("click", () => help.style.display = "block");
document.getElementById("closeHelpBtn").addEventListener("click", () => help.style.display = "none");

/* Resize */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ---------- Start ---------- */
function setDefault() {
  state.current = { Z: 6, N: 8 };
  state.currentPair = null;
  setSceneToCurrent();
  addXP(0);
  updateMeters();
  renderMissions();
  setStepLevel(1);
  missionStatusEl.textContent = "Select a mission (guided) or use Sandbox to explore.";
  showToast("Loaded. Start with Mission 1.");
}
setDefault();

/* ---------- Render Loop ---------- */
let last = performance.now();
function loop(now) {
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;

  controls.update();
  animateFrame(dt);

  nucleusGroup.rotation.y += 0.15 * dt;
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>